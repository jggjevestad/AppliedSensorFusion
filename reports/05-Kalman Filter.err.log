Traceback (most recent call last):
  File "/Users/glenn/miniconda3/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Users/glenn/miniconda3/lib/python3.11/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/glenn/miniconda3/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/glenn/miniconda3/lib/python3.11/asyncio/base_events.py", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/Users/glenn/miniconda3/lib/python3.11/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/Users/glenn/miniconda3/lib/python3.11/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Users/glenn/miniconda3/lib/python3.11/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# Kalman Filter
# Measurement:
# Distance [meter]

# Imports
from numpy import arange, array, eye, sqrt, zeros, random, diag
from numpy.random import normal
from numpy.linalg import inv, norm, cholesky
import matplotlib.pyplot as plt
from vanloan.vanloan import numeval

# System values
dt = 0.05       # interval [second]
samples = 800   # number of samples
num = 3         # number of iterations (design matrix)
r = 1**2        # measurement noise [meter^2]
qv = 0.3**2     # process noise velocity [meter^2/second^3]
qh = 0.1**2     # process noise height [meter^2/second]

# Dynamics matrix
F = array([[0, 1, 0],
           [0, 0, 0],
           [0, 0, 0]])

# White noise coefficients
G = array([[0, 0],
           [sqrt(qv), 0],
           [0, sqrt(qh)]])

# Observation covariance matrix
R = array([[r]])    # [meter^2]

# Initial state
x = array([[-200],  # position [meter]
           [10],    # velocity [meter/second]
           [100]])  # height   [meter]
xt = x

# Inital state covariance matrix
P = diag([5**2, 1**2, 1**2])

# Numerical evaluation (van Loan)
[phi, Q] = numeval(F, G, dt)

# Cholesky decomposition of process noise covariance
C = cholesky(Q)

# Linearized design matrix
def dH(x_nom):
    
    x1 = x_nom[0, 0]
    x3 = x_nom[2, 0]

    dH = array([[x1/sqrt(x1**2 + x3**2), 0, x3/sqrt(x1**2 + x3**2)]])
    
    return dH

# Computed observations
def hx(x_nom):
    
    x1 = x_nom[0, 0]
    x3 = x_nom[2, 0]
    
    z = array([[sqrt(x1**2 + x3**2)]])
    
    return z

# Plot vectors
x_all = []; P_all = []; xt_all =[]
res = []; pos_err = []; hgt_err = []

# Main loop
for k in range(0, samples):
    
    # Process noise vector
    w = array([[0],
               [normal(0, sqrt(qv))],
               [normal(0, sqrt(qh))]])
    
    # Compute true trajectory
    xt = phi@xt + C@w
    
    # Generate noisy measurements
    z = hx(xt) + normal(0, sqrt(r))
    
    # Time update
    xp = phi@x
    Pp = phi@P@phi.T + Q
    
    for i in range(0, num):
        
        # Design matrix
        H = dH(x)
    
        # System size
        [n, e] = H.shape
        
        # Computed observations
        zp = hx(xp)
    
        # Kalman gain
        K = Pp@H.T@inv(H@Pp@H.T + R)
    
        # Measurement update
        x = xp + K@(z - zp)
        P = (eye(e) - K@H)@Pp@(eye(e) - K@H).T + K@R@K.T
    
    # Accumulate plot vectors
    x_all.append(x)
    P_all.append(P)
    xt_all.append(xt)

    res.append(norm(z - zp))
    pos_err.append(norm(xt[0] - x[0]))
    hgt_err.append(norm(xt[2] - x[2]))
    

# Extract plot vectors
pos_est = [x[0, 0] for x in x_all]
vel_est = [x[1, 0] for x in x_all]
hgt_est = [x[2, 0] for x in x_all]

pos_true = [xt[0, 0] for xt in xt_all]
vel_true = [xt[1, 0] for xt in xt_all]
hgt_true = [xt[2, 0] for xt in xt_all]

pos_std = [sqrt(P[0, 0]) for P in P_all]
hgt_std = [sqrt(P[2, 2]) for P in P_all]

# Time
time = arange(0, samples)*dt

plt.figure(1)
plt.plot(time, pos_est, 'g', label = 'Estimated trajectory')
plt.plot(time, pos_true, 'b', label = 'True trajectory')
plt.title('System State')
plt.xlabel('Time (second)')
plt.ylabel('Position (meter)')
plt.legend(loc='lower right')
plt.grid(True, which='both')
plt.show()

plt.figure(2)
plt.plot(time, pos_est, 'g.', label='Estimated trajectory')
plt.plot(time, pos_true, 'b', label='True trajectory')
plt.title('System State (0-50m)')
plt.xlabel('Time (second)')
plt.ylabel('Position (meter)')
plt.xlim(15, 25)
plt.ylim(-50, 50)
plt.legend(loc='lower right')
plt.grid(True, which='both')
plt.show()

plt.figure(3)
plt.plot(time, vel_est, 'g.', label='Estimated velocity')
plt.plot(time, vel_true, 'b', label='True velocity')
plt.title('System State')
plt.xlabel('Time (second)')
plt.ylabel('Velocity (meter/second)')
plt.ylim(8, 12)
plt.legend(loc='lower right')
plt.grid(True, which='both')
plt.show()

plt.figure(4)
plt.plot(time, hgt_est, 'g.', label='Estimated altitude')
plt.plot(time, hgt_true, 'b', label='True altitude')
plt.title('System State')
plt.xlabel('Time (second)')
plt.ylabel('Altitude (meter)')
plt.ylim(98, 102)
plt.legend(loc='lower right')
plt.grid(True, which='both')
plt.show()

plt.figure(5)
plt.plot(time, res, 'r', label='Residuals')
plt.plot(time, pos_err, 'b', label='True error')
plt.plot(time, pos_std, 'g', label='Standard Deviation')
plt.title('Error analysis')
plt.xlabel('Time (second)')
plt.ylabel('Position (meter)')
plt.ylim(0, 5)
plt.legend(loc='upper right')
plt.grid(True, which='both')
plt.show()

plt.figure(6)
plt.plot(time, res, 'r', label='Residuals')
plt.plot(time, hgt_err, 'b', label='True error')
plt.plot(time, hgt_std, 'g', label='Standard Deviation')
plt.title('Error analysis')
plt.xlabel('Time (second)')
plt.ylabel('Altitude (meter)')
plt.ylim(0, 5)
plt.legend(loc='upper right')
plt.grid(True, which='both')
plt.show()
------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mModuleNotFoundError[0m                       Traceback (most recent call last)
Cell [0;32mIn[11], line 10[0m
[1;32m      8[0m [38;5;28;01mfrom[39;00m [38;5;21;01mnumpy[39;00m[38;5;21;01m.[39;00m[38;5;21;01mlinalg[39;00m [38;5;28;01mimport[39;00m inv, norm, cholesky
[1;32m      9[0m [38;5;28;01mimport[39;00m [38;5;21;01mmatplotlib[39;00m[38;5;21;01m.[39;00m[38;5;21;01mpyplot[39;00m [38;5;28;01mas[39;00m [38;5;21;01mplt[39;00m
[0;32m---> 10[0m [38;5;28;01mfrom[39;00m [38;5;21;01mvanloan[39;00m[38;5;21;01m.[39;00m[38;5;21;01mvanloan[39;00m [38;5;28;01mimport[39;00m numeval
[1;32m     12[0m [38;5;66;03m# System values[39;00m
[1;32m     13[0m dt [38;5;241m=[39m [38;5;241m0.05[39m       [38;5;66;03m# interval [second][39;00m

[0;31mModuleNotFoundError[0m: No module named 'vanloan'

